### Dart 자료형

* .runtimeType -> 해당 변수가 실행될 때 어떤 자료형인지 알려준다.

* var (various) -> 모든 자료형을 받을 수 있지만, 최초 선언 후 값을 바꾸는 것이 불가능하다.
* dynamic -> 모든 자료형을 받을 수 있고, ``var(various)`` 과는 다르게 값을 바꾸는 것도 가능하다.
* int (integer) -> ``정수`` 자료형을 받을 수 있다.
* String -> ``문자열`` 자료형을 받을 수 있다.
  * ``(${} ${}) / ($ $) -> 띄어쓰기``
  * ``ex) print(${name} ${name2});``
  * ``ex) print($name $name2);``
  * ``ex) print(name + ' ' + name2);``
* double -> ``실수`` 자료형을 받을 수 있다.
* bool (boolean) -> ``참`` 과 ``거짓`` 을 받을 수 있다.

#### 일부 자료형은 변수에 ``null`` 값을 넣을 수 없지만, 자료형 뒤에 ``?`` 를 붙히면 ``null`` 값도 넣을 수 있다.

* ! -> 어떤 함수를 실행 할 때 변수가 ``null`` 이 들어갈 수 없는 자료형이라면, 변수 뒤에 ``!``를 붙이면 변수가 ``null`` 이 절대 들어갈 수 없다는 것을 의미한다.
* final, const -> ``final, const`` 로 변수를 선언하면 값을 변경할 수 없다.
  ##### 공통점 : ``final, const`` 를 사용하면 ``Type(var)`` 을 생략할 수 있다.
  * ``ex) final String name -> final name`` (const 또한 동일하다.)
  
  ##### 차이점 : ``final`` 은 ``빌드 타임`` (즉, 코드를 기계어(1,0)으로 변환할 때) 을 알고 있지 않아도 되지만, ``const`` 는 빌드 타임을 알고 있어야 한다.
* DataTime 클래스 -> 컴파일 버튼을 누른 시점이 아닌, 코드가 실행되는 시점의 시각을 알려준다.
  * ``ex) (DataTime now = DatieTime.now();)``
* 오퍼레이터 -> ``변수++, --`` 로 값의 증감이 가능하고, ``+=, -=, *=`` 같이 사용도 가능하다.
  * 변수?? = ``값`` -> 변수가 만약에 ``null`` 값이라면 오른쪽 값으로 바꾼다.
* 비교 오퍼레이터 -> 비교식의 값이 참이라면 ``true``, 거짓이라면 ``false`` 를 출력한다.
  * ``>, <, >=, <=, ==, !=``
* 자료형 비교 오퍼레이터 -> 
  * ``변수 is 자료형`` -> 변수의 자료형이 코드에서 물어보는 자료형과 일치하다면 ``true``, 아니라면 ``false`` 를 출력한다.
  * ``변수 is! 자료형`` -> 변수의 자료형이 코드에서 물어보는 자료형과 일치하다면 ``false``, 아니라면 ``true`` 를 출력한다.
* 논리 오퍼레이터 ->
  * ``조건식 && 조건식`` -> 두 조건식 모두 참이라면 참이다.
  * ``조건식 || 조건식`` -> 두 조건식 중 하나의 조건식만 참이여도 참이다. 
* List 클래스 -> ``List<자료형> 이름 = [];``
  * 올바른 자료형의 값을 넣지 않으면 오류가 발생한다.
  * ``List의 이름.`` 으로 다양한 함수들을 찾을 수 있다.
  * ``ex) blackPink.``
  * ``length`` 함수는 ``List`` 의 길이를 센다.
  * ``add`` 함수는 ``List`` 에 값을 추가할 수 있다.
  * ``remove`` 함수는 ``List`` 의 값을 삭제할 수 있다.
  * ``indexOf`` 함수는 ``index(순서)`` 를 알고 싶은 값의 번호를 알 수 있다.
* index -> ``index`` 는 무조건 ``0`` 부터 시작한다.
* Map -> ``List`` 에선 값을 하나하나가 개별의 값이었지만, ``Map`` 같은 경우에는 짝을 이뤄서 값을 넣는다.
  * ``Map<Key(자료형), Value(자료형)> 이름 = {Key : Value};``
  * ``Test.addAll`` 에다 넣은 값을 ``Test``의 ``Map`` 에 추가할 수 있다.
  * ``ex) Test.addAll({ 'Spiderman' : false' });``
  * ``Test['Key'];`` -> ``'Key`` 값에 해당하는 ``Value`` 값을 가져올 수 있다.
  * ``Test.keys`` -> ``Test`` 값에 해당하는 ``Key`` 값을 모두 가져온다.
  * ``Test.values`` -> ``Test`` 값에 해당하는 ``Value`` 값을 모두 가져온다.
* Set -> ``Map`` 처럼 ``Key, Value`` 값이 있지만, ``List`` 처럼 하나의 값만 저장할 수 있다.
  * ``List`` vs ``Set`` -> ``Set`` 은 중복된 값이 들어갈 수 없다. (중복을 자동으로 처리해준다.)
  * ``List`` 와 함수가 비슷하다.
  * ``contains`` 함수는 ``Set`` 에 어떤 값의 존재 유무를 확인할 수 있다.
